#include <boost/lexical_cast.hpp>
#include "cinder/Cinder.h"
#include "cinder/Camera.h"
#include "cinder/app/AppBasic.h"
#include "cinder/gl/gl.h"
#include "cinder/gl/Texture.h"
#include "cinder/gl/Fbo.h"
#include "cinder/gl/GlslProg.h"
#include "zugster/gizmo/Gizmo.h"
#include "zugster/gizmo/Parts.h"
#include "zugster/gizmo/Commands.h"

#pragma comment(lib, "cairo-static.lib")

using namespace cinder;
using namespace cinder::app;
using namespace zugster::gizmo;
using boost::shared_ptr;
using boost::make_shared;

static const int WIDTH  = 512;
static const int HEIGHT = 512;

//=============================================================================
// Gizmo Factory
//=============================================================================

static ColorA  trans    (0.0f, 0.0f, 0.0f, 0.0f);
static ColorA  cyan     (0.0f, 0.7f, 0.8f, 1.0f);
static ColorA  cyan_fill(0.0f, 0.2f, 0.3f, 0.7f);
static PartRef saveCommand      = make_shared<ContextSave>();
static PartRef restoreCommand   = make_shared<ContextRestore>();

// Draw a sim-card shape (just a rectangle with one clipped corner)
void draw_sim(cairo::Context &ctx, const Rectf &rect, int orientation = 0)
{
    float cut_rate = 0.20;
    float cut = rect.getWidth() * cut_rate;
    
    ctx.moveTo(rect.x1, rect.y1);
    ctx.lineTo(rect.x2 - cut, rect.y1);
    ctx.lineTo(rect.x2, rect.y1 + cut);
    ctx.lineTo(rect.x2, rect.y2);
    ctx.lineTo(rect.x1, rect.y2);
    ctx.lineTo(rect.x1, rect.y1);    
}

void custom(GizmoContext &context)
{
    context.save();
    cairo::Context &c = context.Cairo;

    Rectf r(10, 10, 50, 70);
    for ( int i = 0; i < 10; i++ )
    {
        draw_sim(c, r);
        context.fillPreserve();
        c.setSource(context.LineColor);
        c.stroke();

        context.LineColor -= 0.08;
        context.FillColor -= 0.08;
        
        r += Vec2f(50,0);
    }    
    context.restore();
}


GizmoRef make_gizmo(float x, float y, float scale = 1.0)
{
	GizmoRef g = make_shared<Gizmo>(x, y);

	g->push_back(make_shared<SetLinecolor>(cyan));
	g->push_back(make_shared<SetFillcolor>(cyan_fill));

	g->push_back(make_shared<CirclePart>(28 * scale, true /* outline */, true /* fill */));
	g->push_back(make_shared<ArcPart>(30 * scale, 1 * scale, 225, 330));
	g->push_back(make_shared<ArcPart>(30 * scale, 1 * scale, 0, 110));
	g->push_back(make_shared<ArcPart>(32 * scale, 1 * scale, 90, 280));
	g->push_back(make_shared<GradientCirclePart>( 12 * scale, 12 * scale, trans, ColorA(1.0, 1.0, 1.0, 1.0)));
	g->push_back(make_shared<ArcPart>(36 * scale, 4 * scale, 45, 180));
	g->push_back(make_shared<FilledArcPart>(44 * scale, 20 * scale, 330, 30));
    g->back()->setRotationSpeed(5.0);

    g->push_back(saveCommand);
    g->push_back(make_shared<SetLinewidth>(1.5));
    g->push_back(make_shared<SetLinecolor>(ColorA(0.4, 0.4, 0.4, 0.2)));
    g->push_back(make_shared<SetFillcolor>(ColorA(0.2, 0.2, 0.2, 0.2)));
    g->push_back(make_shared<SegmentedFilledArcPart>(22 * scale, 8 * scale, 6, 15));
    g->back()->setRotationSpeed(-5.0);
	g->push_back(restoreCommand);

	g->push_back(saveCommand);
	g->push_back(make_shared<SetLinewidth>(2.0 * scale));
	g->push_back(make_shared<SetLinecolor>(ColorA(1.0, 0.2, 0.2, 0.8)));
	g->push_back(make_shared<RadialLinesPart>(42 * scale, 4 * scale, 6, 220, 280));
	g->push_back(restoreCommand);

	g->push_back(make_shared<CustomFn>(custom));
    
	return g;
}



//=============================================================================
// App
//=============================================================================

class ShadersApp : public AppBasic {
  public:
	void setup();
	void prepareSettings(Settings *settings);
	void mouseDown( MouseEvent event );	
	void keyDown(KeyEvent event);
	void update();
	void draw();

  private:
    void render_texture();
    void render_framebuffer();
    void render_framebuffer_shaded();
    void draw_shaded();
    void draw_plain();
    
    /** Definition of the UI gizmo to draw */
    GizmoRef        m_gizmo;
    /** GL texture to render the gizmo into */
	gl::Texture     m_texture;
    /** Framebuffer to render the gizmo texture into */
    gl::Fbo         m_framebuffer;
    /** Framebuffer to render the results of the shader */
    gl::Fbo         m_framebuffer_shaded;

    gl::GlslProg    m_shader;
    gl::Fbo::Format m_format;
    bool            m_bDrawShaded;
    bool            m_bDrawFrameRate;
};

void ShadersApp::setup()
{
    m_format.enableMipmapping(false);
    m_format.setCoverageSamples(16);
    m_format.setSamples(4);
    
	m_bDrawFrameRate     = false;
    m_bDrawShaded        = true;
	m_gizmo              = make_gizmo( WIDTH / 2, HEIGHT / 2, 4.0 );
    m_framebuffer        = gl::Fbo(WIDTH, HEIGHT, m_format);
    m_framebuffer_shaded = gl::Fbo(WIDTH, HEIGHT, m_format);
    
    try {
//        m_shader = gl::GlslProg(loadResource("v002.AnalogGlitch.vert"),
//                                loadResource("v002.AnalogGlitch.frag"));
//                m_shader = gl::GlslProg(loadResource("v002.blur.vert"),
//                                        loadResource("v002.blur.frag"));
#ifdef _WIN32
                m_shader = gl::GlslProg(loadFile("passThru_vert.glsl"),
                                        loadFile("gaussianBlur_frag.glsl"));
#else
        m_shader = gl::GlslProg(loadResource("passThru_vert.glsl"),
                                loadResource("gaussianBlur_frag.glsl"));
#endif
    } catch ( const std::exception &ex ) {
        std::cout << ex.what() << std::endl;
    }
}

void ShadersApp::prepareSettings(Settings *settings)
{
	settings->setWindowSize( WIDTH, HEIGHT );
	settings->setFrameRate(  30.0f );    
	settings->setTitle("Shader Test");
}

void ShadersApp::mouseDown( MouseEvent event )
{
}

void ShadersApp::keyDown(KeyEvent event)
{
    if ( event.getChar() == 's' )
        m_bDrawShaded = !m_bDrawShaded;
	else if ( event.getChar() == 'f' )
		m_bDrawFrameRate = !m_bDrawFrameRate;
}

void ShadersApp::update()
{
	m_gizmo->update();
    render_texture();
}

void ShadersApp::render_texture()
{
	cairo::SurfaceImage surface( WIDTH, HEIGHT, true );
	cairo::Context      ctx(surface);
	GizmoContext        context(ctx, surface);
    
	ctx.setSource(trans);
	ctx.paint();    	

	m_gizmo->RenderGizmo(context);

	if ( m_bDrawFrameRate )
	{
		ctx.newPath();
		ctx.setSource(Color::white());
		ctx.moveTo(2.0, 10.0);
		ctx.showText(boost::lexical_cast<std::string>(getAverageFps()));
	}

	m_texture = gl::Texture(surface.getSurface());    
}

class SaveViewport {
public:
    SaveViewport()
    {
        m_viewport = gl::getViewport();
    }
    ~SaveViewport()
    {
        gl::setViewport(m_viewport);
    }
private:
    Area m_viewport;
};

void ShadersApp::render_framebuffer()
{
    SaveViewport vp;
    
    m_framebuffer.bindFramebuffer();
    gl::setViewport( m_framebuffer.getBounds() );
    gl::clear();
	gl::setMatricesWindow(WIDTH, HEIGHT, true);
	gl::draw( m_texture, Vec2f(0, 0) );    
    m_framebuffer.unbindFramebuffer();
}

void ShadersApp::render_framebuffer_shaded()
{
    SaveViewport vp;

    m_framebuffer_shaded.bindFramebuffer();
    gl::setViewport( m_framebuffer_shaded.getBounds() );
    
    m_texture.enableAndBind();
	m_shader.bind();
	m_shader.uniform( "tex0", 0 );
	m_shader.uniform( "sampleOffset", Vec2f( cos( .0 ), sin( .0 ) ) * ( 2.0f / getWindowWidth() ) );
	gl::pushMatrices();
	gl::setMatricesWindow(WIDTH, HEIGHT, true);
	gl::drawSolidRect( m_framebuffer_shaded.getBounds() );
	gl::popMatrices();
    m_shader.unbind();
    m_texture.unbind();
    m_framebuffer_shaded.unbindFramebuffer();
}

void ShadersApp::draw_plain()
{
    if ( !m_texture )
		return;
    
	gl::clear( Color( 0, 0, 0 ) ); 
	gl::pushMatrices();
	gl::setMatricesWindow(WIDTH, HEIGHT, true);
	gl::draw( m_framebuffer.getTexture(), Vec2f(0, 0) );
	gl::popMatrices();
}

void ShadersApp::draw_shaded()
{    
    gl::setViewport( getWindowBounds() );
    gl::enableAdditiveBlending();
    gl::color( Color::white() );
	gl::pushMatrices();
	gl::setMatricesWindow(WIDTH, HEIGHT, true);
    gl::draw( m_framebuffer_shaded.getTexture(), getWindowBounds() );
    gl::disableAlphaBlending();     
	gl::popMatrices();
}

void ShadersApp::draw()
{
    if ( !m_texture )
        return;   

	zugster::gizmo::render_to_framebuffer(m_framebuffer, m_gizmo);

    draw_plain();
    
    if ( m_bDrawShaded )
    {
        render_framebuffer_shaded();
        draw_shaded();
    }
}


CINDER_APP_BASIC( ShadersApp, RendererGl );
